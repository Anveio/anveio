#!/usr/bin/env node

import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { mkdir, readFile, readdir, stat, writeFile, copyFile } from 'node:fs/promises'

import sharp from 'sharp'

type Variant = {
	width: number
	height: number
	url: string
}

type ImageManifest = Record<
	string,
	Record<
		string,
		{
			width: number
			height: number
			placeholder: string
			variants: Variant[]
		}
	>
>

const RESIZE_TARGETS = [480, 768, 1024, 1280, 1600]
const BLOG_ROOT = path.join(projectRoot(), 'apps/blog')
const RAW_ROOT = path.join(BLOG_ROOT, 'lib/assets/raw-images')
const PUBLIC_ROOT = path.join(BLOG_ROOT, 'public/blog-assets')
const MANIFEST_DEST = path.join(BLOG_ROOT, 'lib/images/generated.ts')

async function main(): Promise<void> {
	const manifest: ImageManifest = {}

	const slugs = await listSubdirectories(RAW_ROOT)
	for (const slug of slugs) {
		const rawDir = path.join(RAW_ROOT, slug)
		const outputDir = path.join(PUBLIC_ROOT, slug)
		await mkdir(outputDir, { recursive: true })

		const entries = await readdir(rawDir)
		for (const entry of entries) {
			const absolute = path.join(rawDir, entry)
			if (!(await isFile(absolute))) continue

			const baseName = entry.replace(/\.[^.]+$/, '')
			const ext = path.extname(entry).toLowerCase()
			const buffer = await readFile(absolute)
			const image = sharp(buffer)
			const metadata = await image.metadata()

			if (!metadata.width || !metadata.height) {
				console.warn(`Skipping ${entry}: unable to determine dimensions.`)
				continue
			}

			const placeholderBuffer = await image
				.resize({ width: 20 })
				.webp({ quality: 60 })
				.toBuffer()
			const placeholder = `data:image/webp;base64,${placeholderBuffer.toString('base64')}`

			const variants: Variant[] = []
			const availableTargets = RESIZE_TARGETS.filter((width) => width <= metadata.width!)
			const targetWidths = availableTargets.length > 0 ? availableTargets : [metadata.width]

			for (const width of targetWidths) {
				const scale = width / metadata.width
				const height = Math.round(metadata.height * scale)
				const outputName = `${baseName}-${width}.webp`
				const outputPath = path.join(outputDir, outputName)

				await image.resize({ width }).webp({ quality: 82 }).toFile(outputPath)

				variants.push({
					width,
					height,
					url: `/blog-assets/${slug}/${outputName}`,
				})
			}

			// Preserve originals for reference (e.g. OG images)
			const originalPath = path.join(outputDir, entry)
			if (ext === '.jpg' || ext === '.jpeg' || ext === '.png') {
				await copyFile(absolute, originalPath)
			} else if (ext === '.webp') {
				// retain original webp under descriptive name
				await copyFile(absolute, path.join(outputDir, `${baseName}-original${ext}`))
			}

			if (!Object.hasOwn(manifest, slug)) {
				manifest[slug] = {}
			}

			const postManifest = manifest[slug]
			postManifest[baseName] = {
				width: metadata.width,
				height: metadata.height,
				placeholder,
				variants,
			}
		}
	}

	await writeManifest(manifest)
	console.log('Image generation complete.')
}

async function listSubdirectories(root: string): Promise<string[]> {
	const entries = await readdir(root, { withFileTypes: true })
	return entries.filter((entry) => entry.isDirectory()).map((entry) => entry.name)
}

async function isFile(filePath: string): Promise<boolean> {
	try {
		const fileStat = await stat(filePath)
		return fileStat.isFile()
	} catch {
		return false
	}
}

async function writeManifest(manifest: ImageManifest): Promise<void> {
	await mkdir(path.dirname(MANIFEST_DEST), { recursive: true })
	const serialized = JSON.stringify(manifest, null, 2)
	const banner = `// This file is auto-generated by scripts/generate-images.ts. Do not edit manually.\n\n`
	const body = `export const imagesManifest = ${serialized} as const;\n`
	await writeFile(MANIFEST_DEST, banner + body, 'utf8')
}

function projectRoot(): string {
	return path.join(path.dirname(fileURLToPath(import.meta.url)), '..')
}

main().catch((error) => {
	console.error(error)
	process.exitCode = 1
})
