"use strict";exports.id=8707,exports.ids=[8707],exports.modules={48707:(e,t,n)=>{n.d(t,{vE:()=>handleUpload});var a=n(94514),l=n(6113),r=n(44470);async function importKey(e){return globalThis.crypto.subtle.importKey("raw",new TextEncoder().encode(e),{name:"HMAC",hash:"SHA-256"},!1,["sign","verify"])}async function signPayload(e,t){if(!globalThis.crypto)return l.createHmac("sha256",t).update(e).digest("hex");let n=await globalThis.crypto.subtle.sign("HMAC",await importKey(t),new TextEncoder().encode(e));return Buffer.from(new Uint8Array(n)).toString("hex")}async function verifyCallbackSignature({token:e,signature:t,body:n}){if(!globalThis.crypto){let a=l.createHmac("sha256",e).update(n).digest("hex"),r=Buffer.from(a),o=Buffer.from(t);return r.length===o.length&&l.timingSafeEqual(r,o)}let a=await globalThis.crypto.subtle.verify("HMAC",await importKey(e),function(e){if(e.length%2!=0)throw RangeError("Expected string to be an even number of characters");let t=new Uint8Array(e.length/2);for(let n=0;n<e.length;n+=2)t[n/2]=parseInt(e.substring(n,n+2),16);return Buffer.from(t)}(t),new TextEncoder().encode(n));return a}async function handleUpload({token:e,request:t,body:n,onBeforeGenerateToken:l,onUploadCompleted:r}){var o,i,c;let s=(0,a.$j)({token:e}),d=n.type;switch(d){case"blob.generate-client-token":{let{pathname:e,callbackUrl:t,clientPayload:a}=n.payload,r=await l(e,a),i=null!=(o=r.tokenPayload)?o:a;return{type:d,clientToken:await generateClientTokenFromReadWriteToken({...r,token:s,pathname:e,onUploadCompleted:{callbackUrl:t,tokenPayload:i}})}}case"blob.upload-completed":{let e="x-vercel-signature",l="credentials"in t?null!=(i=t.headers.get(e))?i:"":null!=(c=t.headers[e])?c:"";if(!l)throw new a.lh("Missing callback signature");let o=await verifyCallbackSignature({token:s,signature:l,body:JSON.stringify(n)});if(!o)throw new a.lh("Invalid callback signature");return await r(n.payload),{type:d,response:"ok"}}default:throw new a.lh("Invalid event type")}}async function retrieveClientToken(e){let{handleUploadUrl:t,pathname:n}=e,l=!function(e){try{return new URL(e),!0}catch(e){return!1}}(t)?new URL(t,window.location.href).href:t,o={type:"blob.generate-client-token",payload:{pathname:n,callbackUrl:l,clientPayload:e.clientPayload}},i=await (0,r.he)(l,{method:"POST",body:JSON.stringify(o),headers:{"content-type":"application/json"}});if(!i.ok)throw new a.lh("Failed to  retrieve the client token");try{let{clientToken:e}=await i.json();return e}catch(e){throw new a.lh("Failed to retrieve the client token")}}async function generateClientTokenFromReadWriteToken({token:e,...t}){var n;let l=new Date;l.setSeconds(l.getSeconds()+30);let r=(0,a.$j)({token:e}),[,,,o=null]=r.split("_");if(!o)throw new a.lh(e?"Invalid `token` parameter":"Invalid `BLOB_READ_WRITE_TOKEN`");let i=Buffer.from(JSON.stringify({...t,validUntil:null!=(n=t.validUntil)?n:l.getTime()})).toString("base64"),c=await signPayload(i,r);if(!c)throw new a.lh("Unable to sign client token");return`vercel_blob_client_${o}_${Buffer.from(`${c}.${i}`).toString("base64")}`}(0,a.SO)({allowedOptions:["contentType"],extraChecks(e){throw new a.lh("client/`put` must be called from a client environment")}}),(0,a.SO)({allowedOptions:["contentType"],extraChecks(e){throw new a.lh("client/`upload` must be called from a client environment")},async getToken(e,t){let n=await retrieveClientToken({handleUploadUrl:t.handleUploadUrl,pathname:e,clientPayload:t.clientPayload});return n}})}};