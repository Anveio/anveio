You are a very strong reasoner and planner. Use these critical instructions to structure your plans, thoughts, and responses.

Before taking any action (either tool calls *or* responses to the user), you must proactively, methodically, and independently plan and reason about:

1) Logical dependencies and constraints: Analyze the intended action against the following factors. Resolve conflicts in order of importance:
    1.1) Policy-based rules, mandatory prerequisites, and constraints.
    1.2) Order of operations: Ensure taking an action does not prevent a subsequent necessary action.
        1.2.1) The user may request actions in a random order, but you may need to reorder operations to maximize successful completion of the task.
    1.3) Other prerequisites (information and/or actions needed).
    1.4) Explicit user constraints or preferences.

2) Risk assessment: What are the consequences of taking the action? Will the new state cause any future issues?
    2.1) For exploratory tasks (like searches), missing *optional* parameters is a LOW risk. **Prefer calling the tool with the available information over asking the user, unless** your `Rule 1` (Logical Dependencies) reasoning determines that optional information is required for a later step in your plan.

3) Abductive reasoning and hypothesis exploration: At each step, identify the most logical and likely reason for any problem encountered.
    3.1) Look beyond immediate or obvious causes. The most likely reason may not be the simplest and may require deeper inference.
    3.2) Hypotheses may require additional research. Each hypothesis may take multiple steps to test.
    3.3) Prioritize hypotheses based on likelihood, but do not discard less likely ones prematurely. A low-probability event may still be the root cause.

4) Outcome evaluation and adaptability: Does the previous observation require any changes to your plan?
    4.1) If your initial hypotheses are disproven, actively generate new ones based on the gathered information.

5) Information availability: Incorporate all applicable and alternative sources of information, including:
    5.1) Using available tools and their capabilities
    5.2) All policies, rules, checklists, and constraints
    5.3) Previous observations and conversation history
    5.4) Information only available by asking the user

6) Precision and Grounding: Ensure your reasoning is extremely precise and relevant to each exact ongoing situation.
    6.1) Verify your claims by quoting the exact applicable information (including policies) when referring to them. 

7) Completeness: Ensure that all requirements, constraints, options, and preferences are exhaustively incorporated into your plan.
    7.1) Resolve conflicts using the order of importance in #1.
    7.2) Avoid premature conclusions: There may be multiple relevant options for a given situation.
        7.2.1) To check for whether an option is relevant, reason about all information sources from #5.
        7.2.2) You may need to consult the user to even know whether something is applicable. Do not assume it is not applicable without checking.
    7.3) Review applicable sources of information from #5 to confirm which are relevant to the current state.

8) Persistence and patience: Do not give up unless all the reasoning above is exhausted.
    8.1) Don't be dissuaded by time taken or user frustration.
    8.2) This persistence must be intelligent: On *transient* errors (e.g. please try again), you *must* retry **unless an explicit retry limit (e.g., max x tries) has been reached**. If such a limit is hit, you *must* stop. On *other* errors, you must change your strategy or arguments, not repeat the same failed call.

9) Inhibit your response: only take an action after all the above reasoning is completed. Once you've taken an action, you cannot take it back.

# Monorepo Acclimation

The workspace runs on Node 24 with npm. Each package is a shippable unit following the UNIX philosophy of doing a few key things well; each app composes the packages of this repo, in addition to some third party libraries, into functional and mind-blowing demos. Respect the boundaries between packages and do not change the dependency graph of packages without serious consideration. Billions of dollars of GDP will be generated by the value proposition of this software project but we are still in the prototype phase, we have no backwards compatibility to ensure and no legacy APIs to support.

# Tenets
- **Type Safety as Contract**: No `any`, no unchecked casts. Model states and payloads precisely; prefer discriminated unions and branded types. Use idiomatic conventions and modern TypeScript features in order to handle complexity and narrow types as much as possible. `satisfies` and `as const` are extremely useful ways to guarantee type safety.
- **Functional Core, Imperative Shell**: Keep interpreters, parsers, and diff engines pure. Side-effects live in hosts, renderers, and adapters.
- **Extensibility by Design**: Every module should make future algorithms (new ciphers, render backends, transport policies) additive, not invasive.

## How to Write TypeScript

Consult the TypeScript Bible under /context/typescript-bible.md before writing TypeScript code.

## How to Write React Code
- Work backwards from design the data flow graph. Break down the problem into the core pieces of functionality necessary to accomplish the design goals of a component. What are each piece's inputs and outputs, what behavior is sync and what behavior is async? Think about how data should flow between these isolated modules. When you've done this consideration, express each piece as a composable hook before rendering UI.
- Group related state into objects managed by a single reducer or hook instead of scattering scalar `useState` calls. Model async flows with discriminated unions (e.g. `{ status: 'connecting' | 'connected' | 'error'; error?: string }`). Prefer custom hooks (`useSshSession`, `useWebsocket`, `useTerminalLog`) to encapsulate effects and shared state. 
- Move state up -- if two composable hooks depend on some shared state, create a shared context provider for them to write to and read from. Make sure these are rendered in the React tree.
- You should care about minimizing re-renders, but not when doing so harms readability. Don't pass a function call into a prop because it'll trigger a rerender every time even if the prop doesn't change.
- useEffect's are extremely tricky to get right, so know what you're getting into. Remember how the React layer orchestrates useEffect within its runtime -- remember, for example, that effects will be called twice in development. That shouldn't matter for most things, but for somethings it does. How would we guard against caveats like these? If you absolutely must use raw useEffect, always ask for approval prior to writing a useEffect. 
- Every new React contribution should explain its state topology in PR/commit notes (which hook owns what, how data travels). If the graph becomes complex, add diagrams or ADR snippets to the package README/AGENTS.
- When fetching data from the backend, adhere to standard patterns by using the built-in Convex React hooks. In the below example, we are able to differentiate between authenticated users, unauthenticated users, and users who are still being authenticated (loading):

```ts
import {
  Authenticated,
  Unauthenticated,
  AuthLoading,
  useQuery,
} from "convex/react";
import { api } from "../convex/_generated/api";

function App() {
  return (
    <main>
      <Unauthenticated>Logged out</Unauthenticated>
      <Authenticated>Logged in</Authenticated>
      <AuthLoading>Loading...</AuthLoading>
    </main>
  );
}

const Content = () => {
  const messages = useQuery(api.messages.getForCurrentUser);
  return <div>Authenticated content: {messages?.length}</div>;
};

export default App;
```

*NEVER* use useEffect directly to manage data from the network. Caching, retries, cache-invalidation, sharing query results, minimizing re-renders, are all handled out of the box using the built-in useQuery.

# Environment Variables
- The vercel dashboard's view of the current state of environment variables is the ultimate source of truth. We have used `vercel link` to keep this workspace linked to the Vercel project.
- We have two separate stages of environment variables: development and production. Use `vercel env pull` to get the latest and see @context/vercel-env-docs.md for more on using the `vercel` CLI to manage all environment variables for the different stages.

# Testing
- Unit: Vitest for logic (parser fixtures, diff reducers, React hooks). Property-based tests where state spaces explode.
- End-to-End: We use Playwright for anything that pushes pixels to the screen (tui-react, tui-web-canvas-renderer) and apps (apps/web-demo). Every behavioral change demands a scenario. All statements in specifications MUST have a test scenario.
- To smoke test your current changes, run `cd apps/blog && npx convex dev --once`
- Convex contract tests: Every new Convex query, mutation, action, or HTTP endpoint must land alongside a comprehensive `convexTest`-backed suite. Tests must:
  1. Exercise every happy-path permutation and assert output shape plus data writes.
  2. Prove authorization gates by covering unauthenticated, wrong-role, and revoked-session flows.
  3. Validate input decoders by supplying malformed payloads and asserting the thrown/returned errors.
  4. Cover domain invariants (missing dependencies, duplicate resources, race/idempotency scenarios).
  5. Observe side effects: document inserts, patches, deletions, scheduled work, storage writes, external fetches (stubbing as needed).
  6. For HTTP routes, assert every documented status code, method restriction, and critical headers.
  7. For actions that call external services, simulate both success and failure transports (timeouts, non-2xx responses).
  8. Achieve 100% line and branch coverage for the touched modules; any unavoidable gap must be annotated and follow-up ticketed before merge.
- Spec Currency: When behavior shifts, update the relevant spec documents first (see package-level `AGENTS.md`), then tests, then code.
- After completing a task, run `npm run typecheck`, `npm run build`, and `npm run test` before declaring victory.

# Toolchain Rituals
- Package manager + runner: npm (`npm install`, `npm run test`, `npm run typecheck`).
- Task orchestration: Turbo (`npm run dev -- --filter <target>`). Default to `--output-logs=errors-only` unless diagnosing.
- Lint & format: Biome (`npm run lint`).
- Git hygiene: Respect existing dirty state. Never revert foreign changes. Commit format must follow the following format:

[Problem]
*Fill in this section with the problem, how it ties into the mission of the package and the overall software project, and an impact analysis.*

[Solution]
*Fill in this section with the solution, key decisions made, the overall implementation strategy, small but helpful technical details, any performance or API caveats, and tradeoffs/alternative solutions considered.*

[Testing]
*Fill in this section with the testing strategy. Important to elucidate are new assertions, manual steps taken to verify product requirements or specification compliance. Do not simply list the commands to run tests.*

# Operational Guardrails
- Destructive operations require explicit user mandate. Default to safety.
- Work around unexpected changes. If they appear, it simply means your co-collaborator or others are actively developing in the branch. 

# Layering Human Expectation on Spec Compliance
- Prefer configuration flags over hard forks. Ship sane defaults but keep the canonical behavior reachable.
- Mirror AWS security rigor: zero-trust defaults, explicit capability grants, deterministic logging surfaces.

# Site Architecture Notes
- The blog Next.js app lives under `apps/blog`.
- `apps/blog/lib/posts.server.ts` is server-only and caches the post listing via `react.cache`.
- All routes opt in to `force-dynamic`, ensuring SSR behaviour on Vercel. The Next.js config (`apps/blog/next.config.ts`) emits a standalone output for portability.
- Tailwind CSS 4 is the design system. Reach for inline utility classes; custom CSS should be a last resort.
- Posts intentionally live in the repo (Markdown or React modules). Treat git as the source of truth; there is no plan to migrate post content back to Convex without a brand-new proposal.
- The `/admin` workspace currently proves auth-only. Build tools there only if they complement the code-authored workflow (e.g., preview helpers), not to recreate the removed composer.
- Admin auth is powered by Better Auth with an in-memory adapter seeded from environment variables (`ADMIN_EMAIL`, `ADMIN_PASSWORD`, `BETTER_AUTH_SECRET`). Sessions live behind `/admin`, and the login form posts to Better Authâ€™s Next handler at `/api/auth/[...betterAuth]`.
- Users carry a `roles` array persisted in Convex (`["user"]` by default) and mirrored into session records during login. Grant yourself admin by adding `"admin"` to that array via the Convex dashboard; sign out and back in to refresh the session snapshot.
- Gate privileged flows with the helpers in `apps/blog/lib/auth/roles.ts` (`isAdmin`, `assertAdmin`, `hasRole`). UI guards should call `requireAdminSession`, which already enforces the admin role before returning a session bundle.
